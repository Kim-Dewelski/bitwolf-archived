use core::mem::transmute;

use bitmatch_proc::bitmatch;

#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Register {
    R0 = 0,
    R1,
    R2,
    R3,
    R4,
    R5,
    R6,
    R7,
    R8,
    R9,
    R10,
    R11,
    R12,
    R13,
    R14,
    R15,
}

#[derive(Clone, Copy)]
pub enum DpShiftOp {
    Reg,
    Imm,
}

#[derive(Clone, Copy)]
#[repr(u32)]
pub enum DpOp {
    And = 0,
    Eor,
    Sub,
    Rsb,
    Add,
    Adc,
    Sbc,
    Rsc,
    Tst,
    Teq,
    Cmp,
    Cmn,
    Orr,
    Mov,
    Bic,
    Mvn,
}

pub enum DpShiftTy{
    /// Arithmetic shift right 
    Asr,
    /// Logical shift left 
    Lsl,
    /// Logical shift right 
    Lsr,
    /// Rotate right
    Ror,
    /// Rotate right with extend
    Rrx,
}

pub enum DpTy{
    Imm,
    Reg{shift_imm: bool, shift_ty: todo!() }
}

#[derive(Clone, Copy)]
pub enum MiscTransfOp {
    Ldrh,
    Ldrsh,
    Ldrb,
    Ldrsb,
    Strh,
    Strsh,
    Strb,
    Strsb,
}

#[derive(Clone, Copy)]
pub enum MiscTransfAdr {
    PostIndex,
    PreIndex,
    OffsetIndex,
}

pub enum Instr {
    Dp {
        i: bool,
        op: DpOp,
        s: bool,
    },
    Msr,
    Mrs,
    Bx,
    Clz,
    Blx,
    SatAddSub,
    DspMul,
    Swi,
    Mul {
        accumulate: bool,
    },
    Mull {
        accumulate: bool,
    },
    MiscTransfer {
        offset_imm: bool,
        offset_add: bool,
        addressing: MiscTransfAdr,
        op: MiscTransfOp,
    },
    Swp,
    Undef,
}

pub const fn decode_cond(instr: u32) -> Instr {
    let instr = instr & 0x0FFFFFFF;
    // Miscellaneous instructions (3-3)
    if instr & 0x0F90_0010 == 0x0100_0000 || instr & 0x0F90_0090 == 0x0100_0010 {
        // Some miscelanous instructions must be handled before DP instructions due
        // to a 'hole' within the encoding table caused by the opcode field being equal
        // to 0b10xx while S is zero.
        let oper = (instr >> 4) & 0xF;
        let op = (instr >> 21) & 0b11;
        bitmatch!(match oper {
            "0000" => {
                let r = op >> 1 != 0;
                if op & 1 == 0 {
                    Instr::Msr
                } else {
                    Instr::Mrs
                }
            }
            "0001" if op != 0 => {
                if op == 0b01 {
                    Instr::Bx
                } else {
                    Instr::Clz
                }
            }
            "0011" if op == 0b01 => {
                Instr::Blx
            }
            "0101" => {
                Instr::SatAddSub
            }
            "0111" if op == 0b01 => {
                Instr::Swi
            }
            "1yx0" => {
                Instr::DspMul
            }
            _ => Instr::Undef,
        })
    }
    // Data processing immediate shift
    else if instr & 0x0E00_0010 == 0x0000_0000 {
        Instr::Dp {
            i: true,
            op: unsafe { transmute((instr >> 21) & 0xF) },
            s: (instr >> 20) != 0,
        }
    }
    // Data processing register shift
    else if instr & 0x0E00_0090 == 0x0000_0010 {
        Instr::Dp {
            i: false,
            op: unsafe { transmute((instr >> 21) & 0xF) },
            s: (instr >> 20) != 0,
        }
    }
    // Multiples, extra load/stores
    else if instr & 0x0E00_0090 == 0x0000_0090 {
        let oper = (instr >> 5) & 0b11;
        let p = (instr >> 24) & 1 != 0;
        let u = (instr >> 23) & 1 != 0;
        let w = (instr >> 21) & 1 != 0;
        let s = (instr >> 5) & 1 != 0;
        let h = (instr >> 5) & 1 != 0;
        // p == 0
        //  indicates the use of post-indexed addressing. The base register value is used for
        //  the memory address, and the offset is then applied to the base register value and
        //  written back to the base register.
        // p == 1
        //  Indicates the use of offset addressing or pre-indexed addressing (the W bit
        //  determines which). The memory address is generated by applying the offset to
        //  the base register value.
        // U
        //  Indicates whether the offset is added to the base (U == 1) or subtracted from the base
        //  (U == 0).
        // W if p == 0
        //  The W bit must be 0 or the instruction is UNPREDICTABLE.
        // W if p == 1
        //  W == 1 indicates that the memory address is written back to the base register
        //  (pre-indexed addressing), and W == 0 that the base register is unchanged (offset
        //  addressing).
        let adr_mode = 
        // pre-indexed
        if p && w{
            MiscTransfAdr::PreIndex
        } 
        // offset
        else if p && !w{
            MiscTransfAdr::OffsetIndex
        } 
        // UNPREDICTABLE
        else if !p && w{
            todo!()
        } 
        // post-indexed
        else {
            MiscTransfAdr::PostIndex
        };
        bitmatch!(match oper {
            "00" => {
                let bits = (instr >> 20) & 0x1F;
                bitmatch!(match bits {
                    "000as" => Instr::Mul {
                        accumulate: todo!()
                    },
                    "01uas" => Instr::Mull {
                        accumulate: todo!()
                    },
                    "10b00" => Instr::Swp,
                    _ => Instr::Undef,
                })
            }
            "01" => {
                let bit = (instr >> 22) & 1 == 0;
                let l = (instr >> 20) & 1 != 0;
                // L
                //  This bit distinguishes between a Load (L == 1) and a Store (L == 0) instruction.
                let op = if l {
                    MiscTransfOp::Ldrh
                } else {
                    MiscTransfOp::Strh
                };
                if bit {
                    Instr::MiscTransfer {
                        offset_imm: false,
                        offset_add: u,
                        addressing: adr_mode,
                        op,
                    }
                } else {
                    Instr::MiscTransfer {
                        offset_imm: true,
                        offset_add: u,
                        addressing: adr_mode,
                        op,
                    }
                }
            }
            "1?" => {
                let upper = (instr >> 22) & 1 != 0;
                let lower = (instr >> 20) & 1 != 0;
                let single_op = if h {
                    MiscTransfOp::Ldrsh
                } else {
                    MiscTransfOp::Ldrsb
                };
                //1w1 (Load signed halfword/byte immediate offset)
                if upper && lower {
                    Instr::MiscTransfer {
                        offset_imm: true,
                        offset_add: u,
                        addressing: adr_mode,
                        op: single_op,
                    }
                }
                // 1w0 (Load/store two words immediate offset)
                else if upper && !lower {
                    todo!()
                }
                // 0w1 (Load signed halfword/byte register offset)
                else if !upper && lower {
                    Instr::MiscTransfer {
                        offset_imm: false,
                        offset_add: u,
                        addressing: adr_mode,
                        op: single_op,
                    }
                }
                // 0w0 (Load/store two words register offset)
                else {
                    todo!()
                }
            }
            _ => Instr::Undef,
        })
    }
    // Data processing immediate
    else if instr & 0x0E00_0000 == 0x0200_0000 {
        Instr::Dp { i: true, op: , s:  }
    }
    // Undefined Instruction
    else if instr & 0x0FB00_0000 == 0x0300_0000 {
        Instr::Undef
    }
    // Move immediate to status register
    else if instr & 0x0FB0_0000 == 0x0320_0000 {
        todo!()
    }
    // Load/store immediate offset
    else if instr & 0x0E00_0000 == 0x0400_0000 {
        todo!()
    }
    // Load/store register offset
    else if instr & 0x0600_0010 == 0x0600_0000 {
        todo!()
    }
    // Undefined instruction
    else if instr & 0x0600_0010 == 0x0600_0010 {
        Instr::Undef
    }
    // Load/store multiple
    else if instr & 0x0800_0000 == 0x0800_0000 {
        todo!()
    }
    // Branch and branch with link
    else if instr & 0x0E00_0000 == 0x0A00_0000 {
        todo!()
    }
    // Coprocessor load/store and double register transfers
    else if instr & 0x0E00_0000 == 0x0C00_0000 {
        todo!()
    }
    // Coprocessor data processing
    else if instr & 0x0F00_0010 == 0x0E00_0000 {
        todo!()
    }
    // Coprocessor register transfers
    else if instr & 0x0F00_0010 == 0x0E00_0010 {
        todo!()
    }
    // Software interrupt
    else if instr & 0x0F00_0000 == 0x0F00_0000 {
        todo!()
    }
    // Undefined
    else {
        Instr::Undef
    }
}

pub fn decode_uncond(instr: u32) -> Instr {
    todo!()
}

pub fn decode(instr: u32) -> Instr {
    let cond = instr >> 28;
    if cond == 0b1111 {
        decode_uncond(instr)
    } else {
        decode_cond(instr)
    }
}
